# LAMMPS generalized input script for using fix bond/react. The force field section will be
# intialized from the style hints that may or may not be in the read-in files (if not N/As
# will be written and will have to be updated. Generalized LAMMPS input script generated by
# bond_react_merge.py v1.14 / 27 March 2024.

# Please look over the script carefully and adjust what is needed. You may also go into
# src/bond_react_merge/lmp_inscript.py to update default information in this script (if
# desired).

# Additional tip to be able to read a LAMMPS simulated fix bond/react file back into LAMMPS
# if you are on linux. After running a fix bond/react simulation additional information
# is written to the LAMMPS datafile, however LAMMPS can not re-read this information, so
# it must be removed. You may run the following command in Linux:
#     sed -i.bak '/bond_react_props_internal/,$d' FILENAME.data
# Which will create a .bak file of the original FILENAME.data and then remove the section
# in the orginal file that LAMMPS cannot read.


#------------Initialization------------
units           real
dimension       3
boundary        p p p
newton          on


#------------Force Field------------
atom_style      full
bond_style      class2
angle_style     class2
dihedral_style  class2
improper_style  class2
special_bonds   lj/coul 0 0 1

kspace_style    pppm 1.0e-4
pair_style      lj/class2/coul/long 12.0
pair_modify     mix sixthpower

neighbor        2.0 bin
neigh_modify    delay 0 every 1 check yes one 5000 page 100000


#------------Read datafile------------
# The extra/... keywords enable extra B/A/D/I due to topology changes caused by reactions
read_data       UPDATE_ME.data &
                extra/special/per/atom 20 &
                extra/bond/per/atom 10 &
                extra/angle/per/atom 20 &
                extra/dihedral/per/atom 50 &
                extra/improper/per/atom 20

# Reading the other files if needed (shifting them as desired) ...
#read_data       UPDATE_ME1.data add append shift 10  0  0
#read_data       UPDATE_ME2.data add append shift 10  5  5
#read_data       UPDATE_ME3.data add append shift  5 15 15

# Also note that cell_builder.py may be used to randomize
# molecules with easy control over stoichiometric ratio.

#------------Settings------------
variable        myid   string UPDATE_ME  # unique LAMMPS out filenameID
variable        ptemp  equal  300        # processing temp K
variable        nevery equal  10         # attempt reaction every this many steps
variable        pseed  equal  94587113   # probability random number seed (positive integer)
timestep        0.5                      # Might need to be changed
velocity        all create ${ptemp} 4928459 dist gaussian # create some velocities


#------------Read rxn templates------------
molecule        mol1  pre_reaction_1_typed_IFF_merged.lmpmol
molecule        mol2  post_reaction_1_typed_IFF_merged.lmpmol
molecule        mol3  pre_reaction_2_typed_IFF_merged.lmpmol
molecule        mol4  post_reaction_2_typed_IFF_merged.lmpmol


#------------bond/react execution------------
fix      myrxn all bond/react stabilization yes statted_grp .03 &
                react rxn1  all ${nevery} 0.5 6.0 mol1  mol2  pre1-post1_rxn-map_uncommented.txt prob 0.10 ${pseed} stabilize_steps 500 &
                react rxn2  all ${nevery} 0.5 6.0 mol3  mol4  pre2-post2_rxn-map_uncommented.txt prob 0.10 ${pseed} stabilize_steps 500

fix             1 statted_grp_REACT nvt temp ${ptemp} ${ptemp} 100
fix             2 bond_react_MASTER_group temp/rescale 1 ${ptemp} ${ptemp} 10 1


#------------Calculate rxns------------
# You may use the rxnN variables to calculate crosslink
# density and then log in thermo_style custom below
variable        rxn1 equal f_myrxn[1]
variable        rxn2 equal f_myrxn[2]


#------------Thermosettings------------
thermo          2000
thermo_style    custom step temp press density ke pe etotal evdwl ecoul epair &
                ebond eangle edihed eimp v_rxn1 v_rxn2
log             ${myid}.log.lammps
restart         2000 rst1.a.${myid} rst2.a.${myid}


#------------Run------------
run             6000
write_data      ${myid}.data


#------------Generalized Method to write LAMMPS datafiles as a function of crosslink density------------
# Caclulate crosslink density
#variable      rxn1 equal f_myrxn[1]
#variable      rxn2 equal f_myrxn[2]

#variable      trxn equal v_rxn1+v_rxn2 # Sum all rxns
#variable      pxld equal 100*(v_trxn/250) # Assume 250 is max count of the sum of rxn1 and rxn2

# Set run flags to "turn on" and "shut off" after writing a file
#variable      pxld10 equal 0 # 10% fileflag
#variable      pxld20 equal 0 # 20% fileflag
#variable      pxld30 equal 0 # 30% fileflag
#variable      pxld40 equal 0 # 40% fileflag
#variable      pxld50 equal 0 # 50% fileflag
#variable      pxld60 equal 0 # 60% fileflag
#variable      pxld70 equal 0 # 70% fileflag
#variable      pxld80 equal 0 # 80% fileflag
#variable      pxld90 equal 0 # 90% fileflag

# Set check frequency (every N-timesteps check if v_pxld is eligable to be written)
#variable      check equal 100   # check every N-timesteps (if to small check may not occur as quick as the reactions are progressing)
#variable      Run   equal 2     # run time in ns
#variable      i     equal (v_Run*1000000/dt)/v_check # calculate number of for loop iterations

# Run simulation using LAMMPS for loop
#label loop
#variable a loop $i
#run ${check}

# crosslink density percent check
#if "${pxld}>=9   && ${pxld}<=13 && ${pxld10}==0" then "write_data ${myid}_pxld_${pxld}.data" "variable      xld10 equal 1" # 10%
#if "${pxld}>=19  && ${pxld}<=23 && ${pxld20}==0" then "write_data ${myid}_pxld_${pxld}.data" "variable      xld20 equal 1" # 20%
#if "${pxld}>=29  && ${pxld}<=33 && ${pxld30}==0" then "write_data ${myid}_pxld_${pxld}.data" "variable      xld30 equal 1" # 30%
#if "${pxld}>=39  && ${pxld}<=43 && ${pxld40}==0" then "write_data ${myid}_pxld_${pxld}.data" "variable      xld40 equal 1" # 40%
#if "${pxld}>=49  && ${pxld}<=53 && ${pxld50}==0" then "write_data ${myid}_pxld_${pxld}.data" "variable      xld50 equal 1" # 50%
#if "${pxld}>=59  && ${pxld}<=63 && ${pxld60}==0" then "write_data ${myid}_pxld_${pxld}.data" "variable      xld60 equal 1" # 60%
#if "${pxld}>=69  && ${pxld}<=73 && ${pxld70}==0" then "write_data ${myid}_pxld_${pxld}.data" "variable      xld70 equal 1" # 70%
#if "${pxld}>=79  && ${pxld}<=83 && ${pxld80}==0" then "write_data ${myid}_pxld_${pxld}.data" "variable      xld80 equal 1" # 80%
#if "${pxld}>=89  && ${pxld}<=93 && ${pxld90}==0" then "write_data ${myid}_pxld_${pxld}.data" "variable      xld90 equal 1" # 90%

#next a
#jump SELF loop
#label break
#print "***ALL DONE***"
#write_data  ${myid}_pxld_${pxld}_end_of_loop.data