# LAMMPS generalized input script for using fix bond/react. The force field section will be
# intialized from the style hints that may or may not be in the read-in files (if not N/As
# will be written and will have to be updated. Generalized LAMMPS input script generated by
# bond_react_merge.py v1.16 / 2 November 2024.

# Please look over the script carefully and adjust what is needed. You may also go into
# src/bond_react_merge/lmp_inscript.py to update default information in this script (if
# desired).

# Additional tip to be able to read a LAMMPS simulated fix bond/react file back into LAMMPS
# if you are on linux. After running a fix bond/react simulation additional information
# is written to the LAMMPS datafile, however LAMMPS can not re-read this information, so
# it must be removed. You may run the following command in Linux:
#     sed -i.bak '/bond_react_props_internal/,$d' FILENAME.data
# Which will create a .bak file of the original FILENAME.data and then remove the section
# in the orginal file that LAMMPS cannot read.


#------------Initialization------------
units           real
dimension       3
boundary        p p p
newton          on


#------------Force Field------------
atom_style      full
bond_style      class2
angle_style     class2
dihedral_style  class2
improper_style  class2
special_bonds   lj/coul 0 0 1

kspace_style    pppm 1.0e-4
pair_style      lj/class2/coul/long 12.0
pair_modify     mix sixthpower

neighbor        2.0 bin
neigh_modify    delay 0 every 1 check yes one 5000 page 100000


#------------Read datafile------------
# The extra/... keywords enable extra B/A/D/I due to topology changes caused by reactions
read_data       UPDATE_ME.data &
                extra/special/per/atom 20 &
                extra/bond/per/atom 10 &
                extra/angle/per/atom 20 &
                extra/dihedral/per/atom 50 &
                extra/improper/per/atom 20

# Reading the other files if needed (shifting them as desired) ...
#read_data       UPDATE_ME1.data add append shift 10  0  0
#read_data       UPDATE_ME2.data add append shift 10  5  5
#read_data       UPDATE_ME3.data add append shift  5 15 15

# Also note that cell_builder.py may be used to randomize
# molecules with easy control over stoichiometric ratio.

#------------Settings------------
variable        myid   string UPDATE_ME  # unique LAMMPS out filenameID
variable        ptemp  equal  300        # processing temp K
variable        nevery equal  10         # attempt reaction every this many steps
variable        pseed  equal  94587113   # probability random number seed (positive integer)
timestep        0.5                      # Might need to be changed
velocity        all create ${ptemp} 4928459 dist gaussian # create some velocities


#------------Read rxn templates------------
molecule        mol1  new_new_1_pre_merged.lmpmol
molecule        mol2  new_new_1_post_merged.lmpmol
molecule        mol3  new_used_2_pre_merged.lmpmol
molecule        mol4  new_used_2_post_merged.lmpmol
molecule        mol5  used_new_3_pre_merged.lmpmol
molecule        mol6  used_new_3_post_merged.lmpmol
molecule        mol7  used_used_4_pre_merged.lmpmol
molecule        mol8  used_used_4_post_merged.lmpmol


#------------bond/react execution------------
fix      myrxn all bond/react stabilization yes statted_grp .03 &
                react rxn1  all ${nevery} 0.5 6.0 mol1  mol2  pre1-post1_rxn-map_uncommented.txt prob 0.10 ${pseed} stabilize_steps 500 &
                react rxn2  all ${nevery} 0.5 6.0 mol3  mol4  pre2-post2_rxn-map_uncommented.txt prob 0.10 ${pseed} stabilize_steps 500 &
                react rxn3  all ${nevery} 0.5 6.0 mol5  mol6  pre3-post3_rxn-map_uncommented.txt prob 0.10 ${pseed} stabilize_steps 500 &
                react rxn4  all ${nevery} 0.5 6.0 mol7  mol8  pre4-post4_rxn-map_uncommented.txt prob 0.10 ${pseed} stabilize_steps 500

fix             1 statted_grp_REACT nvt temp ${ptemp} ${ptemp} 100
fix             2 bond_react_MASTER_group temp/rescale 1 ${ptemp} ${ptemp} 10 1


#------------Calculate rxns------------
# You may use the rxnN variables to calculate crosslink
# density and then log in thermo_style custom below
variable        rxn1 equal f_myrxn[1]
variable        rxn2 equal f_myrxn[2]
variable        rxn3 equal f_myrxn[3]
variable        rxn4 equal f_myrxn[4]


#------------Thermosettings------------
thermo          2000
thermo_style    custom step temp press density ke pe etotal evdwl ecoul epair &
                ebond eangle edihed eimp v_rxn1 v_rxn2 v_rxn3 v_rxn4
log             ${myid}.log.lammps
restart         2000 rst1.a.${myid} rst2.a.${myid}


#------------Run------------
run             6000
write_data      ${myid}.data


#------------Generalized Method to write LAMMPS datafiles as a function of conversion density------------
# Setup for incremental file writing
#variable      increment  equal 2.5 # set increment to write LAMMPS datafiles in
#variable      previous   equal 0   # set previous converions value (for sequential crosslinking)

# Caclulate conversion
#variable      rxn1 equal f_myrxn[1] # count of reaction1
#variable      rxn2 equal f_myrxn[2] # count of reaction2
#variable      srxn equal v_rxn1+v_rxn2 # Sum all rxns
#variable      mrxn equal 250           # Max possible number of reactions
#variable      conv equal 100*(v_srxn/v_mrxn)+v_previous # Define conversion

# Set check frequency (every N-timesteps check if v_pxld is eligable to be written)
#variable      check equal 100   # check every N-timesteps (if to small check may not occur as quick as the reactions are progressing)
#variable      Run   equal 1     # run time in ns
#variable      r     equal (v_Run*1000000/dt)/v_check # calculate number of for loop iterations

# Run simulation using LAMMPS for loop
#variable previousID equal round(v_previous/v_increment)
#label loop
#variable a loop $r
#run ${check}

#variable integer   equal floor(v_conv%v_increment) # will be zero when it is time to write a file
#variable presentID equal round(v_conv/v_increment) # will be used to only write one file within increment range
#if "${integer} == 0 && ${presentID} != ${previousID}" then &
#    "write_data ${myid}_conversion_${conv}.data" &
#    "variable previousID equal ${presentID}"

#next a
#jump SELF loop
#label break
#print "***ALL DONE***"
#write_data  ${myid}_conversion_${conv}_end_of_loop.data