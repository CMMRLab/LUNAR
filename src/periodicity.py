# -*- coding: utf-8 -*-
"""
@author: Josh Kemppainen
Revision 1.0
April 14th, 2025
Michigan Technological University
1400 Townsend Dr.
Houghton, MI 49931


Inconsistent image flags:
    The image flags for a pair on bonded atoms appear to be inconsistent. Inconsistent means
    that when the coordinates of the two atoms are unwrapped using the image flags, the two
    atoms are far apart. Specifically they are further apart than half a periodic box length.
    Or they are more than a box length apart in a non-periodic dimension. This is usually due
    to the initial data file not having correct image flags for the 2 atoms in a bond that straddles
    a periodic boundary. They should be different by 1 in that case. This is a warning because
    inconsistent image flags will not cause problems for dynamics or most LAMMPS simulations.
    However they can cause problems when such atoms are used with the fix rigid or replicate commands.
    Note that if you have an infinite periodic crystal with bonds then it is impossible to have
    fully consistent image flags, since some bonds will cross periodic boundaries and connect two
    atoms with the same image flag.
    
    https://docs.lammps.org/Howto_triclinic.html
    https://scicomp.stackexchange.com/questions/20165/periodic-boundary-conditions-for-triclinic-box
"""

##############################
# Import Necessary Libraries #
##############################
import math




###################################################
# Get box parameters like LAMMPS and msi2lmp does #
###################################################
def get_box_parameters(m):
    # Find set simulataion cell parameters from LAMMPS datafile
    xline = m.xbox_line.split(); yline = m.ybox_line.split(); zline = m.zbox_line.split()
    xlo = float(xline[0]); xhi = float(xline[1])
    ylo = float(yline[0]); yhi = float(yline[1])
    zlo = float(zline[0]); zhi = float(zline[1])
    lx = xhi - xlo
    ly = yhi - ylo
    lz = zhi - zlo
    yz = m.yz
    xz = m.xz
    xy = m.xy
    
    # Generate transformation matrix to convert to
    # and from fractional or Cartesian coordinates
    #  - THIS IS THE FULL VERSION, below is the sparse version
    # a = np.array([lx, 0.0, 0.0])
    # b = np.array([xy, ly, 0.0])
    # c = np.array([xz, yz, lz])
    # h = np.vstack([a, b, c])
    # h_inv = np.linalg.inv(h)
    
    # Generate transformation matrix to convert to
    # and from fractional or Cartesian coordinates
    # using LAMMPS "sparse matrix" setup
    h = [lx, ly, lz, yz, xz, xy] 
    h_inv = 6*[0]
    h_inv[0] = 1/h[0]
    h_inv[1] = 1/h[1]
    h_inv[2] = 1/h[2]
    h_inv[3] = -h[3] / (h[1]*h[2])
    h_inv[4] = (h[3]*h[5] - h[1]*h[4]) / (h[0]*h[1]*h[2])
    h_inv[5] = -h[5] / (h[0]*h[1])
    
    # General box parameters
    boxlo = [xlo, ylo, zlo]
    boxhi = [xhi, yhi, zhi]
    tilts = [xy, xz, yz]
    return h, h_inv, boxlo, boxhi, tilts


#############################################################
# Convert cartesian to fractional coords (0-1) for one atom #
#   frac = h_inv*(x - x0)                                   #
# where frac is the fractional coordinate, x is the         #
# cartesian coordinate, and x0 is the origin of the         #
# simulation cell in that direction and h_inv is the sparse #
# inverse matrix of h, generated by get_box_parameters(m).  #
#############################################################
def pos2frac(x, y, z, h_inv, boxlo):
    # Align atoms with origin of simulation cell
    dx = x - boxlo[0]
    dy = y - boxlo[1]
    dz = z - boxlo[2]
    
    # Convert to fractional coords
    frac_x = h_inv[0]*dx + h_inv[5]*dy + h_inv[4]*dz
    frac_y = h_inv[1]*dy + h_inv[3]*dz
    frac_z = h_inv[2]*dz
    return frac_x, frac_y, frac_z 


#############################################################
# Convert fractional (0-1) to cartesian coords for one atom #
#   x = h*frac + x0                                         #
# where frac is the fractional coordinate, x is the         #
# cartesian coordinate, and x0 is the origin of the         #
# simulation cell in that direction and h is the sparse     #
# h matrix, generated by get_box_parameters(m).             #
#############################################################
def frac2pos(frac_x, frac_y, frac_z, h, boxlo):
    pos_x = h[0]*frac_x + h[5]*frac_y + h[4]*frac_z + boxlo[0]
    pos_y = h[1]*frac_y + h[3]*frac_z + boxlo[1]
    pos_z = h[2]*frac_z + boxlo[2]
    return pos_x, pos_y, pos_z


#########################################################################
# Function to unwrap atoms in an orthogonal or triclinc simulation cell #
#########################################################################
def unwrap_atoms(m):    
    # Generate transformation matrix to convert to
    # and from fractional or Cartesian coordinates
    h, h_inv, boxlo, boxhi, tilts = get_box_parameters(m)
    
    # Generate graph
    graph = {i:[] for i in m.atoms}
    for i in m.bonds:
        id1, id2 = m.bonds[i].atomids
        graph[id1].append(id2)
        graph[id2].append(id1)
    
    # Iterative unwrapping
    checked = {ID:False for ID in m.atoms}
    for ID in graph:
        if checked[ID]:
            continue
        queue = [ID]
        while queue:
            id1 = queue.pop(0) 
            for id2 in graph[id1]:
                if checked[id2]: continue
                atom1 = m.atoms[id1]
                atom2 = m.atoms[id2]
                
                # Convert to fractional and find delta's
                frac_x1, frac_y1, frac_z1 = pos2frac(atom1.x, atom1.y, atom1.z, h_inv, boxlo)
                frac_x2, frac_y2, frac_z2 = pos2frac(atom2.x, atom2.y, atom2.z, h_inv, boxlo)
                delta_x = frac_x2 - frac_x1
                delta_y = frac_y2 - frac_y1
                delta_z = frac_z2 - frac_z1

                # Apply minimum image convention
                shift_x = round(delta_x)
                shift_y = round(delta_y)
                shift_z = round(delta_z)
                frac_mic_x = delta_x - shift_x
                frac_mic_y = delta_y - shift_y
                frac_mic_z = delta_z - shift_z
                mic_x, mic_y, mic_z = frac2pos(frac_mic_x, frac_mic_y, frac_mic_z, h, boxlo)

                # Unwrap positions
                unwrapped_x = atom1.x + mic_x - boxlo[0]
                unwrapped_y = atom1.y + mic_y - boxlo[1]
                unwrapped_z = atom1.z + mic_z - boxlo[2]

                # Update atom parameters (the negative of the
                # shift indicates the image the atom has been moved
                # to, however we will reset the image flags since
                # the atoms where unwrapped for consistency).
                atom2.x = unwrapped_x
                atom2.y = unwrapped_y
                atom2.z = unwrapped_z
                atom2.ix = 0 #-shift_x
                atom2.iy = 0 #-shift_y
                atom2.iz = 0 #-shift_z
                
                queue.append(id2)
                checked[id2] = True
    return m


#######################################################################
# Function to wrap atoms in an orthogonal or triclinc simulation cell #
#######################################################################
def wrap_atoms(m): 
    # Generate transformation matrix to convert to
    # and from fractional or Cartesian coordinates
    h, h_inv, boxlo, boxhi, tilts = get_box_parameters(m)
    
    # Iterative wrapping
    for i in m.atoms:
        atom = m.atoms[i]
        
        # Reset image flags
        frac_x, frac_y, frac_z = pos2frac(atom.x, atom.y, atom.z, h_inv, boxlo)
        image_x = math.floor(frac_x)
        image_y = math.floor(frac_y)
        image_z = math.floor(frac_z)

        # Move atoms using image flags (setting boxlo with zeros, as no shifts
        # are required since these are just diplacements set by the image flags)
        disp_x, disp_y, disp_z = frac2pos(image_x, image_y, image_z, h, [0, 0, 0])
        wrapped_x = atom.x - disp_x
        wrapped_y = atom.y - disp_y
        wrapped_z = atom.z - disp_z

        # Update atom parameters
        atom.x = wrapped_x
        atom.y = wrapped_y
        atom.z = wrapped_z
        atom.ix = image_x
        atom.iy = image_y
        atom.iz = image_z
    return m


##############################################################
# Function to reset image flags in an orthogonal or triclinc #
# simulation cell, which respects the molecular connectivity #
##############################################################
def reset_image_flags(m):
    if m.bonds:
        m = unwrap_atoms(m)
        m = wrap_atoms(m)
    return m
    
    
